숫자로 출력할것과 별로 출력할것을 구분..


=== 문자열

처음에 케릭터때만 언급 했던거

기본적으로 문자열은 포인터와 배열의 관계를 알아야 사용할수있어서...

c언어창시자 - 데니스리치  처음엔 영어만 사용할수있는 문자체계를 만들려고 아스키코드를 만들고


--sbcs (single byte charcter set ) : 1바이트 문자체계를 가진 시스템

초창기 crt모니터 : 검 흰 or 검 초록

286 - 단색형태

386 - 색

인텔 펜티엄세대 -- 윈도우 탑재가능

각국언어 중 핵심언어라고 할 수 있는 구성언어들을 모아서 문자체계들을 만들어서 제공한게 유니코드!

--mbcs ( multi byte charcter set : 1바이트와 2바이트 문자 체계를 가진 시스템.

우리가 사용하고 있는 메인함수가 mbcs기반

a b c d 4개

ㄱ ㄴ ㄷ ㄹ 8개  

다국적 기반이라는것이 공용화되어야하는데 호환 될 수있게끔 코드를 짜야하기에 골치아픈 문제를 야기가능


--wbcs ( wide byte character set ) : 2바이트 문자로 통합시킨 체계를 가진 시스템

api를 배우는 시점부터 wbcs로 전환 !!

윈도우 기반에서 사용된 모든 프로그램들은 다 유니코드 기반으로 실행됨!


당장 수업은 우리가 mbcs로 하고있으니 아스키코드의 케릭터방식을 배워boza

wchar_t



---문자 : ' ' 로 묶음, 아스키코드 한 글자를 의미
---문자열 : " " 로 묶음, 2바이트 이상의 글자를 의미

ex) "ㄱ" , "Helloworld" 

여러글자를 동시에 저장하고싶다.. 

char szTemp[5 ] (스트링이라고 불러서 s가붙고 zero라서 z가붙음) = { 'j' , 'u' , 's' , 'i' , 'n' }

for(int i = 0; i<5 ; ++i)

cout << szTemp[i] << endl;

cout << szTemp << endl;


char szTemp[5] = "jusin" ;    ( 눈에 보이지 않는 널문자가 하나 포함되어있다.. '\0' = null문자

우리가 문자열을 선언하는 순간 메모리 공간에 등록이 됨
어디에?  "jusin"  -- 문자열 상수   -- 케릭터 프린터형

주신을 선언하면 똑같은걸 쓸때마다 같은 주소를 참조함    - 데이터 영역에 올려놔서 종료때까지 계속 저장됨.

char* pTemp = "jusin" ;

cout << pTemp << endl;  --- 출력됨!   주신이라는 상수자체가 주소값!!!!!!!!!

메모리공간에  j u s i n 을 아스키코드형태의 숫자로 만들고 올려놓

주소를 알아서 컴파일러가 갔더니 ( 얻어온 주소의 첫번째주소) 어디까지 접근 가능한지 알수가없음.. 0을만나면 여기까지가 문자열 공간이다를
알려줘서 널문자가 삽입이 되어있는 상태다!!!!

결국 "jusin" 은 1바이트의 null을 포함한 6바이트!

즉 배열의 크기를 하나 더 늘려줘야함

*** 큰따옴표로 묶었을 경우에 null문자가 존재하고 있다는걸 꼭 알고 있어야함!!!!

문자열 선언을 큼직큼직하게 해놓음 보통
요즘엔 메모리 남아도니까.. 너무 꼭 맞춰 쓸 필요는 없지만 그래도 문자열 길이의  +1 만큼 메모리를 할당하는 습관을 들여놓자!!


szTemp[2] = 'A' ;  -  잘 들어감


문자열은 배열을 전제로 하기때문에 포문을 돌릴수있다

for(int i = 0; '\0' != szTemp[i] ; ++i)    널문자를 만나기전까지!! 접근하는법
cout << szTemp[i] << endl;   

문자열 상수를 저장하기 위해서 케릭터 포인터를 선언하는데 포인터형으로 만들고 배열로 만들수있다

char* pArray[3] = {"jusin" , "game" , "academy" } ;

for ( int i = 0; i<3 ; ++i)
cout << pArray[i] << endl; -- 출력 잘됨

** 문자 배열과 분자열 상수의 차이점

- 둘 다 문자열의 시작 주소를 갖고 있다는 측면은 동일함
- 문자 배열의 경우 문자 하나하나를 배열의 원소로 담고 있다.
- 문자 배열은 char* const p 와 같은 경우와 동일하다.
- 문자열 상수는 데이터 영역(상수 메모리) 에 등록된 문자열의 시작 주소를 의미한다. ---  상식정도로알아두자
- 문자열 상수는 const char* p와 같은 경우이다.


-- char szName[32] = "";

cin >> szName;                       배열의 이름에 입력해라
cout << szName << endl;          배열의 이름을 출력하라... - 일반적으로는 맞지않다 왜냐하면 배열의 이름은 상수형 주소값이니까!

배열의 이름은 자료형 - 케릭터 포인터형
cout 이란 아이가 사실은 클래스형인데 케릭터 포인터형일때만** 다르게 설계됨.. (나중에 연산자 오버로딩 템플릿 특수? 같은거에 쓸수있)

char* pName = nullptr;       ** 포인터에 문자열 상수를 넣고 출력하는건 됨 하지만 포인터를 선언하고 입력을 받겠다! 
                                         에는 주소값을 바로 넣는 개념이 아니라 에러걸리는듯?  ( 안된다라고 일단 생각하자 ㅋㅋ)
                                       채팅창이라고 생각해보면 다쳐놓고 문자열 상수로 만들고 포인터에 저장한다치면..
                                       상수주소는 나중에 동적할당 배우고... 저장해놓고 할거임

cin >> pName;
cout << pName << endl;

문자열끼리 대입을 하고싶다??

문자열 함수..

char szName[32] = "jusin";
char szTemp[32] = ""

szTemp = szName;

cout << szTemp <<endl;

-- 배열의 이름은 상수형태의 주소..잖아

대입은 아니지만 복사해주는 함수가 있다!!! 

strcpy_s( ) ;     -- 문자열 복사 함수             너무너무 많이쓰여서 암기하고 쓸 줄 알아야함!!!

- 반환값이 인트형 매개변수는 3개

strcpy_s(szTemp , sizeof (char) * 32 , szName);
          복사받을 문자배열의 이름 복사받을 공간의 메모리크기 복


strcat_s( );    -- 문자열 결합 함수

strcat_s( szName , sizeof(char)* 32 , szTemp);                        -- 경로편집같은곳에 많이 쓰임
            최종결과값을 가진 배열의 이름 , 결합이 끝난 문자열을 저장할 메모리 , 결합할 함수..
cout << szName << endl;

char szName[32] = "jusin";
char szTemp[32] = "_acadamy"


strcmp:  비교할 두 문자열을 매개변수로 넣어줌, 만약 두 문자열이 일치하면 0을 반환, 불 일치하면 1을 반환

if(strcmp(szName, szTemp))                          -- 대부분 그래서 이걸 쓸떄는 not연산자 !을 붙인다
{
 cout << "일치" << endl;
}
else
cout << "불일치" << endl;


문자열 길이 반환 함수: null문자를 제외한 순수한 문자열의 길이를 구하여 반환하는 함수

cout << strlen(szName) << endl;     -- string length줄임말   - 이친구는 널문자를 제외한 순수 글자의 길이수를 반환함!!


적어도 학원을 졸업할때까지는 정말 많이 쓸거니까 무조건무조건 암기하세요!!!!!! ㅠㅠㅠㅠㅠㅠㅠㅠ

여러가지 문자열 함수 검색으로 찾아보고 써보자아




오늘의 숙제

1. 문자열을 입력 받고 null문자를 제외한 순수한 문자열의 길이를 구하는 함수를 만드시오.  (strlen 함수를 직접 구현하라)

2. 문자열 뒤집기 함수 만들기 ( ex : jusin -> nisuj)




